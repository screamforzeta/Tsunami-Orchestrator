"""
Module for processing JSON files generated by Tsunami and creating Excel reports.

This module provides functionality to:
- Process JSON files containing information about vulnerabilities and network services.
- Save the processed results in an Excel file with separate sheets for host information and vulnerabilities.
- Handle common errors such as missing files, insufficient permissions, and invalid JSON data.

Main functionalities:
- `process_all_json_in_directory`: Processes all JSON files in a specified directory.
- `process_json_based_on_vulnerability`: Determines if a JSON file contains vulnerabilities and processes it accordingly.
- `no_vuln_process`: Handles JSON files without vulnerabilities.
- `found_vuln_process`: Handles JSON files with vulnerabilities.
- `append_to_excel` and `append_vuln`: Add processed data to Excel sheets.
- `adjust_excel_column_width`: Dynamically adjusts the column width in Excel sheets.

The module is designed to be run as a main script, with an entry point `main` that processes JSON files in the "Tsunami_outputs" directory and saves results in the "Parsed_report" directory.

Handled exceptions:
- File not found (`FileNotFoundError`).
- Insufficient permissions (`PermissionError`).
- JSON decoding errors (`json.JSONDecodeError`).
- Generic errors (`Exception`).

Dependencies:
- `os`, `json`, `shutil`: For file and directory management.
- `openpyxl`: For Excel file manipulation.
- `classes.Entry` and `classes.Vuln_entry`: Custom classes to represent processed data.

"""

import os
import json
import shutil
from typing import List
from datetime import datetime
from openpyxl import load_workbook

from classes import Entry, Vuln_entry

def process_all_json_in_directory(input_directory: str, output_folder: str) -> int:
    """
    Processes all JSON files in a specified directory and saves the results in an Excel file.

    Parameters:
        input_directory (str): The directory containing the JSON files to process.
        output_folder (str): The directory where the Excel files and processed JSON files will be saved.

    Returns:
        int:
            0: If processing was successful.
            -1: If the directory does not exist or is empty.
            -2: If there are permission issues.
            -3: If a generic error occurs.
            Other error codes may be propagated from `process_json_based_on_vulnerability`.
    """
    try:
        time = datetime.now()
        
        # Iterate over all files in the directory
        for filename in os.listdir(input_directory):
            if filename.endswith(".json"):
                json_path = os.path.join(input_directory, filename)
                result = process_json_based_on_vulnerability(json_path, output_folder, time)
                if result < 0:
                    return result # Propagate the error
        
        adjust_excel_column_width(output_folder, "Host Infos", time)
        adjust_excel_column_width(output_folder, "Vulnerability list", time)
        
        return 0
    except FileNotFoundError:
        print(f"Error: The directory '{input_directory}' does not exist.")
        return -1
    except PermissionError:
        print(f"Error: Insufficient permissions to access the directory '{input_directory}'.")
        return -2
    except Exception as e:
        print(f"Generic error while processing the directory '{input_directory}': {e}")
        return -3
    
def process_json_based_on_vulnerability(json_path: str, output_folder: str, time: datetime) -> int:
    """
    Processes a JSON file based on the presence of vulnerabilities and saves the results in an Excel file.

    Parameters:
        json_path (str): The path to the JSON file to process.
        output_folder (str): The directory where the processed results will be saved.

    Returns:
        int:
            0: If processing was successful.
            -5: If the JSON file does not exist.
            -6: If the JSON file is not valid.
            -7: If there are permission issues.
            -8: If a generic error occurs.
    """
    try:
        # Load the JSON file
        with open(json_path, "r", encoding="utf-8") as file:
            data = json.load(file)

        # Check if fullDetectionReports is empty
        if not data.get("fullDetectionReports", {}).get("detectionReports"):
            result = no_vuln_process(json_path, output_folder, time)
            if result < 0:
                return result  # Propagate the error
        else:
            result = found_vuln_process(json_path, output_folder, time)
            if result < 0:
                return result  # Propagate the error
        return 0
    except FileNotFoundError:
        print(f"Error: The file '{json_path}' does not exist.")
        return -5
    except json.JSONDecodeError:
        print(f"Error: The file '{json_path}' is not a valid JSON.")
        return -6
    except PermissionError:
        print(f"Error: Insufficient permissions to access the file '{json_path}'.")
        return -7
    except Exception as e:
        print(f"Generic error while processing the file '{json_path}': {e}")
        return -8 
    
def no_vuln_process(json_path: str, output_folder: str, time: datetime) -> int:
    """
    Processes a JSON file that does not contain vulnerabilities and saves the results in an Excel file.

    Parameters:
        json_path (str): The path to the JSON file to process.
        output_folder (str): The directory where the processed results will be saved.

    Returns:
        int:
            0: If processing was successful.
            -1: If a generic error occurs.
    """
    try:
        # Load the JSON file
        with open(json_path, "r", encoding="utf-8") as file:
            data = json.load(file)

        # Check if there are no network services
        if not data.get("reconnaissanceReport", {}).get("networkServices"):
            entries = process_no_network_services(data)
            for entry in entries:
                append_to_excel(entry, output_folder, time)
            return 0

        # Iterate over network services
        for entry_data in data["reconnaissanceReport"]["networkServices"]:
            entry_obj = process_network_endpoint(entry_data)
            append_to_excel(entry_obj, output_folder, time)

        return 0
    
    except KeyError as e:
        print(f"Error: Missing field in JSON file '{json_path}': {e}")
        return -1
    except Exception as e:
        print(f"Error while processing the JSON file: {e}")
        return -1     

def process_network_services(data: dict) -> List[Entry]:
    """
    Processes network services and creates a list of Entry objects.

    Parameters:
        data (dict): The loaded JSON data.

    Returns:
        List[Entry]: A list of Entry objects created from the network services.
    """
    entries = []
    network_services = data.get("reconnaissanceReport", {}).get("networkServices", [])

    # Check that networkServices is a list
    if not isinstance(network_services, list):
        print("Error: 'networkServices' is not a valid list.")
        return entries  # Return an empty list in case of error

    for entry_data in network_services:
        try:
            ip = entry_data.get('networkEndpoint', {}).get('ipAddress', {}).get('address', None)
            port = entry_data.get('networkEndpoint', {}).get('port', {}).get('portNumber', None)
            tp = entry_data.get('transportProtocol', None)
            servicename = entry_data.get('serviceName', None)
            swnm = entry_data.get('software', {}).get('name', None)
            swvs = None

            # Check if versionSet exists and contains versions
            if 'versionSet' in entry_data:
                for version in entry_data['versionSet'].get('versions', []):
                    if "fullVersionString" in version:
                        swvs = version['fullVersionString']
                        break

            cpes = entry_data.get('cpes', None)
            banner = entry_data.get('banner', None)

            # Create an Entry object and add it to the list
            entry_obj = Entry(ip, port, tp, servicename, swnm, swvs, cpes, banner)
            entries.append(entry_obj)
        except KeyError as e:
            print(f"Error: Missing field in network service data: {e}")
            continue

    # Return a list of Entry objects
    return entries    

def process_network_endpoint(entry_data: dict) -> Entry:
    """
    Processes a single network endpoint and creates an Entry object.

    Parameters:
        entry_data (dict): The network endpoint data to process.

    Returns:
        Entry: An Entry object containing the processed information.
    """
    
    try:
        ip = entry_data['networkEndpoint']['ipAddress']['address']
        port = entry_data['networkEndpoint']['port']['portNumber']
        tp = entry_data['transportProtocol']
        servicename = entry_data['serviceName']

        # Check if `serviceContext` exists
        service_context = entry_data.get('serviceContext', {}).get('webServiceContext', {})
        swnm = service_context.get('software', {}).get('name', None)

        # If `serviceContext` does not contain `software`, check the upper level
        if swnm is None:
            swnm = entry_data.get('software', {}).get('name', None)

        # Check if `versionSet` exists
        swvs = None
        if 'versionSet' in service_context:
            for version in service_context['versionSet'].get('versions', []):
                if "fullVersionString" in version:
                    swvs = version['fullVersionString']
                    break
        elif 'versionSet' in entry_data:
            for version in entry_data['versionSet'].get('versions', []):
                if "fullVersionString" in version:
                    swvs = version['fullVersionString']
                    break

        # Check if `cpes` exists
        cpes = entry_data.get('cpes', None)

        # Create and return the Entry object
        return Entry(ip, port, tp, servicename, swnm, swvs, cpes, None)
    except KeyError as e:
        print(f"Error: Missing field in endpoint data: {e}")
        return Entry(None, None, None, None, None, None, None, None)  # Fallback value


def process_no_network_services(data: dict) -> List[Entry]:
    """
    Processes targets without network services and creates a list of Entry objects.

    Parameters:
        data (dict): The loaded JSON data.

    Returns:
        List[Entry]: A list of Entry objects created from targets without network services.
    """
    entries = []
    for entry_data in data["reconnaissanceReport"]["targetInfo"]["networkEndpoints"]:
        ip = entry_data['ipAddress']['address']
        entry_obj = Entry(ip, None, None, None, None, None, None, None)
        entries.append(entry_obj)
    return entries

def found_vuln_process(json_path: str, output_folder: str, time: datetime) -> int:
    """
    Processes a JSON file that contains vulnerabilities and saves the results in an Excel file.

    Parameters:
        json_path (str): The path to the JSON file to process.
        output_folder (str): The directory where the processed results will be saved.

    Returns:
        int:
            0: If processing was successful.
            -1: If a generic error occurs.
    """
    
    try:
        with open(json_path, "r", encoding="utf-8") as file:
            data = json.load(file)

        # Iterate over network services with vulnerabilities
        full_detection_report = data["fullDetectionReports"]["detectionReports"]
        if data["reconnaissanceReport"]["networkServices"]:
            entries = process_network_services(data)
            for entry in entries:
                append_to_excel(entry, output_folder, time)
        elif data["reconnaissanceReport"]["networkEndpoint"]:
            entries = process_network_endpoint(data)
            append_to_excel(entry, output_folder, time)
        
        
        for report in full_detection_report:
            try:
                # Host infos
                ip_address = report["targetInfo"]["networkEndpoints"][0]["ipAddress"]["address"]  
                port = report["networkService"]["networkEndpoint"]["port"]["portNumber"]
                
                # Vulnerability details
                v_name = report["vulnerability"]["title"]
                v_publisher = report["vulnerability"]["mainId"]["publisher"]
                v_severity = report["vulnerability"]["severity"]
                v_description = report["vulnerability"]["description"] 
                v_recommendation = report["vulnerability"]["recommendation"]  

                v = Vuln_entry(ip_address, port, v_name, v_publisher, v_severity, v_description, v_recommendation)
                append_vuln(v, output_folder, time)
                
            except KeyError as e:
                print(f"Error: Missing field in report data: {e}")
                continue
        return 0
        
    except KeyError as e:
        print(f"Error: Missing field in JSON file '{json_path}': {e}")
        return -1
    except Exception as e:
        print(f"Error while processing the JSON file: {e}")
        return -1
        
def append_to_excel(data: Entry, output_path: str, time: datetime) -> int:
    """
    Adds an Entry object to the "Host Infos" sheet of an Excel file.

    Parameters:
        data (Entry): The Entry object to add.
        output_path (str): The directory where the Excel file is located.

    Returns:
        int:
            0: If the operation was successful.
            -1: If an error occurs.
    """
    excel_path = os.path.join(output_path, f"findings_{time.strftime('%H-%M-%S')}.xlsx")
    template_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), "Templates", "Excel_template.xlsx")
    try:
        # Ensure the output directory exists
        if not os.path.exists(output_path):
            os.makedirs(output_path)

        # Ensure the template file exists
        if not os.path.exists(template_path):
            print(f"Error: The template file '{template_path}' does not exist.")
            return -1

        # Create the Excel file if it does not exist
        if not os.path.exists(excel_path):
            shutil.copy(template_path, excel_path)

        # Convert the Entry object to a dictionary
        data_dict = json.loads(data.to_json())

        # Convert any lists to strings
        for key, value in data_dict.items():
            if isinstance(value, list):
                data_dict[key] = ", ".join(map(str, value))  # Convert the list to a comma-separated string

        # Load the existing Excel file
        workbook = load_workbook(excel_path)
        sheet_name = "Host Infos"

        # Check if the sheet exists
        if sheet_name not in workbook.sheetnames:
            # Create the sheet if it does not exist
            sheet = workbook.create_sheet(sheet_name)
            # Write the header
            sheet.append(list(data_dict.keys()))
        else:
            sheet = workbook[sheet_name]

        # Add the data to the existing sheet
        sheet.append(list(data_dict.values()))

        # Save the Excel file
        workbook.save(excel_path)

    except PermissionError:
        print(f"Error: Insufficient permissions to access '{output_path}' or '{template_path}'.")
        return -1
    except Exception as e:
        print(f"Error while processing the Excel file: {e}")
        return -1

def append_vuln(data: Vuln_entry, output_path: str, time: datetime) -> int:
    """
    Adds a Vuln_entry object to the "Vulnerability list" sheet of an Excel file.

    Parameters:
        data (Vuln_entry): The Vuln_entry object to add.
        output_path (str): The directory where the Excel file is located.

    Returns:
        int:
            0: If the operation was successful.
            -1: If an error occurs.
    """
    excel_path = os.path.join(output_path, f"findings_{time.strftime('%H-%M-%S')}.xlsx")
    template_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), "Templates", "Excel_template.xlsx")
    try:
        # Ensure the output directory exists
        if not os.path.exists(output_path):
            os.makedirs(output_path)

        # Ensure the template file exists
        if not os.path.exists(template_path):
            print(f"Error: The template file '{template_path}' does not exist.")
            return -1

        # Create the Excel file if it does not exist
        if not os.path.exists(excel_path):
            shutil.copy(template_path, excel_path)

        # Convert the Vuln_entry object to a dictionary
        data_dict = json.loads(data.to_json())

        # Convert any lists to strings
        for key, value in data_dict.items():
            if isinstance(value, list):
                data_dict[key] = ", ".join(map(str, value))  # Convert the list to a comma-separated string
    
        # Load the existing Excel file
        workbook = load_workbook(excel_path)
        sheet_name = "Vulnerability list"

        # Check if the sheet exists
        if sheet_name not in workbook.sheetnames:
            # Create the sheet if it does not exist
            sheet = workbook.create_sheet(sheet_name)
            # Write the header
            sheet.append(list(data_dict.keys()))
        else:
            sheet = workbook[sheet_name]

        # Add the data to the existing sheet
        sheet.append(list(data_dict.values()))

        # Save the Excel file
        workbook.save(excel_path)

    except PermissionError:
        print(f"Error: Insufficient permissions to access '{output_path}' or '{template_path}'.")
        return -1
    except Exception as e:
        print(f"Error while processing the Excel file: {e}")
        return -1

def adjust_excel_column_width(output_folder: str, sheet_name: str, time: datetime) -> None:
    """
    Dynamically adjusts the column width in an Excel sheet.

    Parameters:
        output_folder (str): The directory where the Excel file is located.
        sheet_name (str): The name of the sheet to modify.

    Returns:
        None
    """
    workbook = load_workbook(os.path.join(output_folder, f"findings_{time.strftime('%H-%M-%S')}.xlsx"))

    try:
        ws = workbook[sheet_name]  # Get the specified sheet
        for col in ws.columns:
            max_length = 0
            col_letter = col[0].column_letter  # Get the column letter
            for cell in col:
                try:
                    if cell.value:  # Check if the cell has a value
                        max_length = max(max_length, len(str(cell.value)))
                except Exception as e:
                    print(f"Error while calculating column width: {e}")
            ws.column_dimensions[col_letter].width = max_length + 8  # Set the column width
        workbook.save(os.path.join(output_folder, f"findings_{time.strftime('%H-%M-%S')}.xlsx"))  # Save the Excel file
    except KeyError:
        print(f"Error: The sheet '{sheet_name}' does not exist in the Excel file.")
    except Exception as e:
        print(f"Error while adjusting column widths: {e}")
        
def main():
    """
    Module entry point.

    Processes all JSON files in the "Tsunami_outputs" directory
    and saves the results in the "Parsed_report" directory.
    """
    base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    parsed_report_dir = os.path.join(base_dir, "Parsed_report")
    try:
        result = process_all_json_in_directory(os.path.join(base_dir, "Tsunami_outputs"), parsed_report_dir)
        if result < 0:
            print(f"Error while processing JSON files. Error code: {result}")
    except Exception as e:
        print(f"Generic error during program execution: {e}")

if __name__ == "__main__":
    main()